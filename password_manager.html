<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Advanced Secure Password Manager</title>
    <style>
      body {
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        line-height: 1.6;
        color: #333;
        margin: 0 auto;
        padding: 20px;
        background-color: #f5f7fa;
      }
      .d-flex {
        display: flex;
      }
      .container {
        display: flex;
        flex-wrap: wrap;
        max-width: 1200px;
        margin: 0 auto;
        gap: 20px;
        justify-content: space-between;
      }

      .card {
        background: white;
        border-radius: 8px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        padding: 20px;
        max-width: 1600px;
        margin: 0 auto;
        margin-bottom: 20px;
        flex: 1;
        min-width: 300px;
      }

      h1,
      h2,
      h3 {
        color: #2c3e50;
      }

      h1 {
        text-align: center;
        margin-bottom: 30px;
      }

      input,
      button,
      select {
        padding: 10px;
        margin: 8px 0;
        border-radius: 4px;
        border: 1px solid #ddd;
        width: 100%;
        box-sizing: border-box;
      }

      input:focus,
      select:focus {
        outline: none;
        border-color: #3498db;
        box-shadow: 0 0 0 2px rgba(52, 152, 219, 0.2);
      }

      button {
        background-color: #3498db;
        color: white;
        cursor: pointer;
        font-weight: bold;
        border: none;
        transition: background-color 0.3s;
      }

      button:hover {
        background-color: #2980b9;
      }

      table {
        width: 100%;
        border-collapse: collapse;
        margin-top: 20px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        background: white;
        border-radius: 8px;
        overflow: hidden;
      }

      th,
      td {
        padding: 12px 15px;
        text-align: left;
        border-bottom: 1px solid #ddd;
      }

      th {
        background-color: #3498db;
        color: white;
        font-weight: 500;
      }

      tr:nth-child(even) {
        background-color: #f9f9f9;
      }

      tr:hover {
        background-color: #f1f1f1;
      }

      .status-message {
        padding: 10px;
        margin: 10px 0;
        border-radius: 4px;
        text-align: center;
      }

      .success {
        background-color: #d4edda;
        color: #155724;
        border: 1px solid #c3e6cb;
      }

      .error {
        background-color: #f8d7da;
        color: #721c24;
        border: 1px solid #f5c6cb;
      }

      .password-info {
        margin-top: 20px;
        font-size: 0.9em;
        color: #666;
      }

      .hide {
        display: none;
      }

      /* For mobile */
      @media (max-width: 768px) {
        .container {
          flex-direction: column;
        }
      }

      /* Range slider styles */
      .range-container {
        margin: 15px 0;
      }

      .range-container label {
        display: block;
        margin-bottom: 5px;
      }

      .slider-with-value {
        display: flex;
        align-items: center;
        gap: 10px;
      }

      input[type='range'] {
        flex-grow: 1;
      }

      .iterations-value,
      .keylength-value {
        min-width: 80px;
        text-align: center;
        font-weight: bold;
      }

      .performance-info {
        margin-top: 10px;
        padding: 8px;
        background-color: #eef7fd;
        border-radius: 4px;
        border-left: 4px solid #3498db;
      }

      .crypto-options {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 10px;
        margin-bottom: 15px;
      }

      @media (max-width: 600px) {
        .crypto-options {
          grid-template-columns: 1fr;
        }
      }

      .option-group {
        margin-bottom: 12px;
      }

      .option-group label {
        display: block;
        font-weight: 500;
        margin-bottom: 5px;
      }
    </style>
  </head>
  <body>
    <div class="d-flex">
      <div style="align-content: center; margin: auto">
        <h1>Advanced Secure Password Manager</h1>
      </div>
      <div style="align-content: center; margin: auto">
        <button
          id="clearStorageBtn"
          style="background-color: #e74c3c; width: auto"
        >
          Clear All User Data
        </button>
      </div>
    </div>

    <div class="container">
      <div class="card">
        <h2>Register New User</h2>
        <div id="registerStatus" class="status-message hide"></div>
        <form id="registerForm">
          <input type="text" id="newUsername" placeholder="Username" required />
          <input
            type="password"
            id="newPassword"
            placeholder="Password"
            required
          />

          <div class="crypto-options">
            <div class="option-group">
              <label for="registerHashFunction">Hash Function:</label>
              <select id="registerHashFunction">
                <option value="SHA-256">SHA-256</option>
                <option value="SHA-384">SHA-384</option>
                <option value="SHA-512">SHA-512</option>
              </select>
            </div>

            <div class="option-group">
              <label for="registerSaltLength">Salt Length:</label>
              <select id="registerSaltLength">
                <option value="16">16 bytes</option>
                <option value="24">24 bytes</option>
                <option value="32">32 bytes</option>
              </select>
            </div>
          </div>

          <div class="range-container">
            <label for="registerIterations">PBKDF2 Iterations:</label>
            <div class="slider-with-value">
              <input
                type="range"
                id="registerIterations"
                min="10000"
                max="500000"
                step="10000"
                value="100000"
              />
              <span id="registerIterationsValue" class="iterations-value"
                >100,000</span
              >
            </div>
          </div>

          <div class="range-container">
            <label for="registerKeyLength">Key Length (bits):</label>
            <div class="slider-with-value">
              <input
                type="range"
                id="registerKeyLength"
                min="128"
                max="512"
                step="64"
                value="256"
              />
              <span id="registerKeyLengthValue" class="keylength-value"
                >256</span
              >
            </div>
          </div>

          <button type="submit">Register</button>
        </form>

        <div class="password-info">
          <p>Password will be securely stored using:</p>
          <ul>
            <li>Unique salt with configurable length</li>
            <li>PBKDF2 with selectable hash function</li>
            <li>User-configurable iterations</li>
            <li>Adjustable key length for stronger security</li>
          </ul>
        </div>

        <div id="registerPerformance" class="performance-info hide">
          <p><strong>Performance results:</strong></p>
          <p id="registerTimeResult"></p>
        </div>
      </div>

      <div class="card">
        <h2>Login</h2>
        <div id="loginStatus" class="status-message hide"></div>
        <form id="loginForm">
          <input type="text" id="username" placeholder="Username" required />
          <input
            type="password"
            id="password"
            placeholder="Password"
            required
          />

          <div class="range-container">
            <label for="loginIterations">PBKDF2 Iterations for Demo:</label>
            <div class="slider-with-value">
              <input
                type="range"
                id="loginIterations"
                min="10000"
                max="500000"
                step="10000"
                value="100000"
              />
              <span id="loginIterationsValue" class="iterations-value"
                >100,000</span
              >
            </div>
          </div>

          <button type="submit">Login</button>
        </form>

        <div id="loginPerformance" class="performance-info hide">
          <p><strong>Performance results:</strong></p>
          <p id="loginTimeResult"></p>
          <p id="loginConfigResult"></p>
        </div>
      </div>

      <div class="card">
        <h2>Change Password</h2>
        <div id="changeStatus" class="status-message hide"></div>
        <form id="changePasswordForm">
          <input
            type="text"
            id="changeUsername"
            placeholder="Username"
            required
          />
          <input
            type="password"
            id="currentPassword"
            placeholder="Current Password"
            required
          />
          <input
            type="password"
            id="newPassword2"
            placeholder="New Password"
            required
          />

          <div class="crypto-options">
            <div class="option-group">
              <label for="changeHashFunction">New Hash Function:</label>
              <select id="changeHashFunction">
                <option value="SHA-256">SHA-256</option>
                <option value="SHA-384">SHA-384</option>
                <option value="SHA-512">SHA-512</option>
              </select>
            </div>

            <div class="option-group">
              <label for="changeSaltLength">New Salt Length:</label>
              <select id="changeSaltLength">
                <option value="16">16 bytes</option>
                <option value="24">24 bytes</option>
                <option value="32">32 bytes</option>
              </select>
            </div>
          </div>

          <div class="range-container">
            <label for="changeIterations">New PBKDF2 Iterations:</label>
            <div class="slider-with-value">
              <input
                type="range"
                id="changeIterations"
                min="10000"
                max="500000"
                step="10000"
                value="100000"
              />
              <span id="changeIterationsValue" class="iterations-value"
                >100,000</span
              >
            </div>
          </div>

          <div class="range-container">
            <label for="changeKeyLength">New Key Length (bits):</label>
            <div class="slider-with-value">
              <input
                type="range"
                id="changeKeyLength"
                min="128"
                max="512"
                step="64"
                value="256"
              />
              <span id="changeKeyLengthValue" class="keylength-value">256</span>
            </div>
          </div>

          <button type="submit">Change Password</button>
        </form>

        <div id="changePerformance" class="performance-info hide">
          <p><strong>Performance results:</strong></p>
          <p id="changeTimeResult"></p>
          <p id="changeConfigResult"></p>
        </div>
      </div>

      <div class="card">
        <h2>Delete User</h2>
        <div id="deleteStatus" class="status-message hide"></div>
        <form id="deleteUserForm">
          <input
            type="text"
            id="deleteUsername"
            placeholder="Username"
            required
          />
          <input
            type="password"
            id="deletePassword"
            placeholder="Password"
            required
          />
          <button type="submit" style="background-color: #e74c3c">
            Delete User
          </button>
        </form>
        <p class="password-info">
          This action cannot be undone. User will be permanently removed.
        </p>
      </div>
    </div>

    <div class="card">
      <h2>User Database</h2>
      <p>
        This table shows all registered users and their security details
        including performance metrics and crypto configuration
      </p>
      <table id="userTable">
        <thead>
          <tr>
            <th>Username</th>
            <th>Hash Function</th>
            <th>Salt (Hex)</th>
            <th>Salt Len</th>
            <th>Hash (Hex, first 16 chars)</th>
            <th>Iterations</th>
            <th>Key Length</th>
            <th>Encoding Time (ms)</th>
            <th>Actions</th>
          </tr>
        </thead>
        <tbody id="userTableBody">
          <!-- User data will be populated here -->
        </tbody>
      </table>
    </div>

    <script>
      /**
       * Advanced Secure Password Storage and Verification Tool with Performance Tracking
       * Features:
       * - Configurable hash functions (SHA-256, SHA-384, SHA-512)
       * - Adjustable key length (128 to 512 bits)
       * - Configurable salt length (16, 24, 32 bytes)
       * - Adjustable PBKDF2 iterations
       * - Performance tracking and comparison for both encoding and decoding
       */
      class PasswordManager {
        constructor(defaultOptions = {}) {
          // Default options
          this.defaultOptions = {
            iterations: 100000,
            keyLength: 256,
            hashFunction: 'SHA-256',
            saltLength: 16,
            ...defaultOptions,
          };

          this.passwordStore = new Map();

          // Try to load data from localStorage
          this.loadFromStorage();
        }

        // Storage methods
        saveToStorage() {
          // Convert Map to array of entries
          const entries = Array.from(this.passwordStore.entries());

          // Convert to JSON string and store
          localStorage.setItem('passwordManager', JSON.stringify(entries));
        }

        loadFromStorage() {
          const stored = localStorage.getItem('passwordManager');
          if (stored) {
            try {
              // Parse JSON and convert back to Map
              const entries = JSON.parse(stored);
              this.passwordStore = new Map(entries);
              console.log('Loaded from storage:', this.passwordStore);
            } catch (e) {
              console.error('Failed to load from storage:', e);
            }
          }
        }

        clearStorage() {
          localStorage.removeItem('passwordManager');
          this.passwordStore.clear();
        }

        // Core crypto methods
        generateSalt(length = this.defaultOptions.saltLength) {
          // Generate a random salt of the specified length
          // using the Web Crypto API
          const salt = new Uint8Array(length); // this will be a Uint8Array of the specified length
          // the unit8array is a typed array that represents an array of 8-bit unsigned integers
          // for example, if length is 16, the salt will be a Uint8Array of 16 bytes
          crypto.getRandomValues(salt);
          // The getRandomValues method fills the passed typed array with cryptographically secure random values
          return salt;
        }

        stringToBuffer(str) {
          return new TextEncoder().encode(str); // Convert string to Uint8Array
        }

        // Convert buffer to hex string by mapping each byte to hex
        // and joining them together
        bufferToHex(buffer) {
          return Array.from(new Uint8Array(buffer))
            .map((b) => b.toString(16).padStart(2, '0'))
            .join('');
        }

        hexToBuffer(hexString) {
          const bytes = new Uint8Array(hexString.length / 2); // Create a Uint8Array of half the length of the hex string because each byte is represented by 2 hex characters
          for (let i = 0; i < hexString.length; i += 2) {
            // Iterate over the hex string in steps of 2 because each byte is represented by 2 hex characters
            bytes[i / 2] = parseInt(hexString.substr(i, 2), 16); // Convert each pair of hex characters to a byte and store it in the Uint8Array we created earlier bytes array which was half the length of the hex string and that's why we divide i by 2 to get the index of the byte in the bytes array
          }
          return bytes.buffer;
        }

        // Derive key using PBKDF2
        async deriveKey(password, salt, options = {}) {
          // Merge with default options we gave in the constructor
          // The options parameter is optional and can be used to override the default options
          const config = {
            ...this.defaultOptions,
            ...options,
          };

          const passwordBuffer = this.stringToBuffer(password);

          // Import the password as a raw key
          // This is necessary for PBKDF2 to work
          // The key will be used to derive the bits
          // using the PBKDF2 algorithm
          // The key will not be extractable, as we don't need it
          // after deriving the bits
          // The key will be used for deriving bits only
          // The key will be used for PBKDF2 only
          //False: means that the key cannot be exported or retrieved from the browser's cryptographic storage once it has been imported. also means cannot fetch using exportKey method

          const importedKey = await crypto.subtle.importKey(
            'raw', // Import the password as a raw key which is a Uint8Array
            passwordBuffer, // The password is a Uint8Array, so we can use it directly
            { name: 'PBKDF2' }, // The algorithm to use for importing the key
            false, // The key is not extractable, as we don't need it after deriving the bits
            ['deriveBits'] // The key will be used for deriving bits only which means we can use it for PBKDF2
          );
          //3.5 PBKDF2 Internal Mechanism

          // Initialization: Setup with password, salt, iterations, hash function
          // Core Algorithm: Derived key = T₁ || T₂ || ... || Tₙ (where || is concatenation and n = ceil(KeyLength / HashLength))
          // Block Calculation: Each block Tᵢ = F(Password, Salt, Iterations, i)
          // F Function: F(P, S, c, i) = U₁ ⊕ U₂ ⊕ ... ⊕ Uᶜ (where ⊕ is XOR) and c is the number of iterations
          // U Values:
          // HMAC meanss Hash-based Message Authentication Code : a specific construction for creating a MAC (Message Authentication Code) based on a cryptographic hash function.
          // U₁ = HMAC(Password, Salt || i)
          // U₂ = HMAC(Password, U₁)
          // U₃ = HMAC(Password, U₂)
          // And so on...

          // Final Key: DK = T₁ || T₂ || ... || Tₙ (where n = ceil(KeyLength / HashLength))
          return crypto.subtle.deriveBits(
            {
              name: 'PBKDF2', // The algorithm to use for deriving the bits
              salt: salt, // The salt is a Uint8Array, so we can use it directly
              iterations: config.iterations, // The number of iterations to use for PBKDF2
              hash: config.hashFunction, // The hash function to use for PBKDF2
            },
            importedKey, // The key to use for deriving the bits
            config.keyLength // 8, // The length of the derived key in bits (256 bits = 32 bytes)
          );
        }

        // User management methods with performance tracking
        async storePassword(username, password, options = {}) {
          // Check if username already exists
          if (this.passwordStore.has(username)) {
            throw new Error('Username already exists');
          }

          // Merge with default options
          const config = {
            ...this.defaultOptions,
            ...options,
          };

          const salt = this.generateSalt(config.saltLength);

          // Start time measurement
          const startTime = performance.now();
          const derivedKey = await this.deriveKey(password, salt, config);
          const endTime = performance.now();
          const timeTaken = endTime - startTime;

          const passwordData = {
            salt: this.bufferToHex(salt), // Store salt as hex string
            hash: this.bufferToHex(derivedKey), // Store derived key as hex string which is the hash and we got it from the deriveKey method
            iterations: config.iterations,
            keyLength: config.keyLength, // Store key length in bits showing the length of the derived key in bits
            hashFunction: config.hashFunction,
            saltLength: config.saltLength,
            timeTaken: timeTaken.toFixed(2),
            // verificationTime: 'N/A', // Initialize with N/A for decode time
          };

          this.passwordStore.set(username, passwordData);
          this.saveToStorage();

          return { ...passwordData, timeTaken };
        }

        async verifyPassword(username, password, overrideOptions = null) {
          const passwordData = this.passwordStore.get(username);

          if (!passwordData) {
            return { isValid: false };
          }

          const salt = new Uint8Array(this.hexToBuffer(passwordData.salt));

          // If we have override options, use them, otherwise use stored configuration
          const config = overrideOptions
            ? {
                iterations:
                  overrideOptions.iterations || passwordData.iterations,
                hashFunction: passwordData.hashFunction,
                keyLength: passwordData.keyLength,
                saltLength: passwordData.saltLength,
              }
            : {
                iterations: passwordData.iterations,
                hashFunction: passwordData.hashFunction,
                keyLength: passwordData.keyLength,
                saltLength: passwordData.saltLength,
              };

          // Start time measurement
          const startTime = performance.now();
          // we will use the deriveKey method to derive the key from the password and salt using the PBKDF2 algorithm
          const derivedKey = await this.deriveKey(password, salt, config);
          const endTime = performance.now();
          const timeTaken = endTime - startTime;

          const derivedKeyHex = this.bufferToHex(derivedKey);
          const isValid = derivedKeyHex === passwordData.hash;

          // Update verification time in database if this is a successful verification
          // with the original configuration (not demo mode)
          if (isValid && !overrideOptions) {
            // Update the user data with the new verification time
            // this we will be showing below the login form
            passwordData.verificationTime = timeTaken.toFixed(2);
            // Store back in the map
            this.passwordStore.set(username, passwordData);
            // Save to localStorage
            this.saveToStorage();

            // Log for debugging
            console.log(
              `Updated verification time for ${username}: ${timeTaken.toFixed(
                2
              )} ms`
            );
          }

          return {
            isValid,
            timeTaken: timeTaken.toFixed(2),
            originalConfig: { ...passwordData },
            usedConfig: config,
            usingCustomConfig: overrideOptions !== null,
          };
        }

        getUsers() {
          return Array.from(this.passwordStore.keys());
        }

        getUserData() {
          return Array.from(this.passwordStore.entries()).map(
            ([username, data]) => ({
              username,
              ...data,
            })
          );
        }

        async changePassword(
          username,
          oldPassword,
          newPassword,
          newOptions = {}
        ) {
          const verificationResult = await this.verifyPassword(
            username,
            oldPassword
          );

          if (!verificationResult.isValid) {
            return { changed: false };
          }

          // Remove the old entry first to avoid the "already exists" error
          const oldConfig = this.passwordStore.get(username);
          this.passwordStore.delete(username);

          const storeResult = await this.storePassword(
            username,
            newPassword,
            newOptions
          );

          return {
            changed: true,
            oldConfig,
            oldTime: verificationResult.timeTaken,
            newConfig: newOptions,
            newTime: storeResult.timeTaken,
          };
        }

        async deleteUser(username, password) {
          const verificationResult = await this.verifyPassword(
            username,
            password
          );

          if (!verificationResult.isValid) {
            return false;
          }

          const deleted = this.passwordStore.delete(username);
          this.saveToStorage();
          return deleted;
        }
      }

      // Initialize app
      const passwordManager = new PasswordManager();
      const clearStorageBtn = document.getElementById('clearStorageBtn');

      // DOM references
      const registerForm = document.getElementById('registerForm');
      const loginForm = document.getElementById('loginForm');
      const changePasswordForm = document.getElementById('changePasswordForm');
      const userTableBody = document.getElementById('userTableBody');

      // Status messages
      const registerStatus = document.getElementById('registerStatus');
      const loginStatus = document.getElementById('loginStatus');
      const changeStatus = document.getElementById('changeStatus');
      const deleteStatus = document.getElementById('deleteStatus');

      // Performance info elements
      const registerPerformance = document.getElementById(
        'registerPerformance'
      );
      const registerTimeResult = document.getElementById('registerTimeResult');
      const loginPerformance = document.getElementById('loginPerformance');
      const loginTimeResult = document.getElementById('loginTimeResult');
      const loginConfigResult = document.getElementById('loginConfigResult');
      const changePerformance = document.getElementById('changePerformance');
      const changeTimeResult = document.getElementById('changeTimeResult');
      const changeConfigResult = document.getElementById('changeConfigResult');

      // Register form inputs
      const registerHashFunction = document.getElementById(
        'registerHashFunction'
      );
      const registerSaltLength = document.getElementById('registerSaltLength');
      const registerIterations = document.getElementById('registerIterations');
      const registerIterationsValue = document.getElementById(
        'registerIterationsValue'
      );
      const registerKeyLength = document.getElementById('registerKeyLength');
      const registerKeyLengthValue = document.getElementById(
        'registerKeyLengthValue'
      );

      // Login form inputs
      const loginIterations = document.getElementById('loginIterations');
      const loginIterationsValue = document.getElementById(
        'loginIterationsValue'
      );

      // Change password form inputs
      const changeHashFunction = document.getElementById('changeHashFunction');
      const changeSaltLength = document.getElementById('changeSaltLength');
      const changeIterations = document.getElementById('changeIterations');
      const changeIterationsValue = document.getElementById(
        'changeIterationsValue'
      );
      const changeKeyLength = document.getElementById('changeKeyLength');
      const changeKeyLengthValue = document.getElementById(
        'changeKeyLengthValue'
      );

      // Helper function to show status messages
      function showStatus(element, message, isSuccess) {
        element.textContent = message;
        element.classList.remove('hide', 'success', 'error');
        element.classList.add(isSuccess ? 'success' : 'error');

        // Auto-hide after 3 seconds
        setTimeout(() => {
          element.classList.add('hide');
        }, 3000);
      }

      // Clear storage button
      clearStorageBtn.addEventListener('click', () => {
        if (confirm('Are you sure you want to clear all user data?')) {
          passwordManager.clearStorage();
          updateUserTable();
          alert('All user data cleared!');
        }
      });

      // Format numbers with commas
      function formatNumber(num) {
        return num.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ',');
      }

      // Update slider displays on change
      registerIterations.addEventListener('input', function () {
        registerIterationsValue.textContent = formatNumber(this.value);
      });

      registerKeyLength.addEventListener('input', function () {
        registerKeyLengthValue.textContent = this.value;
      });

      loginIterations.addEventListener('input', function () {
        loginIterationsValue.textContent = formatNumber(this.value);
      });

      changeIterations.addEventListener('input', function () {
        changeIterationsValue.textContent = formatNumber(this.value);
      });

      changeKeyLength.addEventListener('input', function () {
        changeKeyLengthValue.textContent = this.value;
      });

      // Update the user table
      function updateUserTable() {
        userTableBody.innerHTML = '';

        const userData = passwordManager.getUserData();

        if (userData.length === 0) {
          const row = document.createElement('tr');
          row.innerHTML = '<td colspan="10">No users registered yet</td>';
          userTableBody.appendChild(row);
          return;
        }

        userData.forEach((user) => {
          const row = document.createElement('tr');

          // Show only first 16 chars of hash for brevity
          const truncatedHash = user.hash.substring(0, 16) + '...';
          // const truncatedHash = user.hash;

          // Show only first part of salt for brevity
          const truncatedSalt = user.salt.substring(0, 16) + '...';
          // const truncatedSalt = user.salt;

          // Make sure verification time is properly displayed
          // const verificationTime = user.verificationTime || 'N/A';

          row.innerHTML = `
            <td>${user.username}</td>
            <td>${user.hashFunction}</td>
            <td title="${user.salt}">${truncatedSalt}</td>
            <td>${user.saltLength} bytes</td>
            <td title="${user.hash}">${truncatedHash}</td>
            <td>${formatNumber(user.iterations)}</td>
            <td>${user.keyLength} bits</td>
            <td>${user.timeTaken} ms</td>
            <td>
                <button type="button" class="delete-btn" data-username="${
                  user.username
                }" 
                    style="background-color: #e74c3c; width: auto; padding: 5px 10px;">
                    Delete
                </button>
            </td>
          `;

          userTableBody.appendChild(row);
        });
      }

      // Register form submission
      registerForm.addEventListener('submit', async (e) => {
        e.preventDefault();

        const username = document.getElementById('newUsername').value;
        const password = document.getElementById('newPassword').value;

        // Get crypto config
        const options = {
          hashFunction: registerHashFunction.value,
          saltLength: parseInt(registerSaltLength.value),
          iterations: parseInt(registerIterations.value),
          keyLength: parseInt(registerKeyLength.value),
        };

        try {
          const result = await passwordManager.storePassword(
            username,
            password,
            options
          );
          showStatus(
            registerStatus,
            `User ${username} registered successfully!`,
            true
          );

          // Show performance data below the register form
          registerTimeResult.innerHTML = `
            Password encoding took ${result.timeTaken} ms with:<br>
            • ${formatNumber(options.iterations)} iterations<br>
            • ${options.hashFunction} hash function<br>
            • ${options.keyLength}-bit key length<br>
            • ${options.saltLength}-byte salt
          `;
          registerPerformance.classList.remove('hide');

          registerForm.reset();
          registerIterations.value = 100000;
          registerIterationsValue.textContent = '100,000';
          registerKeyLength.value = 256;
          registerKeyLengthValue.textContent = '256';
          updateUserTable();
        } catch (error) {
          showStatus(registerStatus, error.message, false);
        }
      });

      // Login form submission
      loginForm.addEventListener('submit', async (e) => {
        e.preventDefault();

        const username = document.getElementById('username').value;
        const password = document.getElementById('password').value;
        const demoIterations = parseInt(loginIterations.value);

        // Only override iterations if the slider value is different from default
        const defaultValue = 100000;
        const overrideOptions =
          demoIterations !== defaultValue
            ? {
                iterations: demoIterations,
              }
            : null;

        const result = await passwordManager.verifyPassword(
          username,
          password,
          overrideOptions
        );

        if (result.isValid) {
          showStatus(loginStatus, `Welcome back, ${username}!`, true);

          // Show performance data
          loginTimeResult.textContent = `Password verification took ${result.timeTaken} ms`;

          // Show config details
          if (result.usingCustomConfig) {
            loginConfigResult.innerHTML = `
              <strong>Using demo configuration:</strong><br>
              • ${formatNumber(
                overrideOptions.iterations
              )} iterations (demo)<br>
              • ${result.originalConfig.hashFunction} hash function<br>
              • ${result.originalConfig.keyLength}-bit key length<br>
              • ${result.originalConfig.saltLength}-byte salt<br>
              <em>Note: Stored password uses ${formatNumber(
                result.originalConfig.iterations
              )} iterations</em>
            `;
          } else {
            loginConfigResult.innerHTML = `
              <strong>Using stored configuration:</strong><br>
              • ${formatNumber(result.originalConfig.iterations)} iterations<br>
              • ${result.originalConfig.hashFunction} hash function<br>
              • ${result.originalConfig.keyLength}-bit key length<br>
              • ${result.originalConfig.saltLength}-byte salt
            `;
          }

          loginPerformance.classList.remove('hide');

          loginForm.reset();
          loginIterations.value = 100000;
          loginIterationsValue.textContent = '100,000';

          // Update the table to show the new verification time
          updateUserTable();
        } else {
          showStatus(loginStatus, 'Invalid username or password', false);
          loginPerformance.classList.add('hide');
        }
      });

      // Change password form submission
      changePasswordForm.addEventListener('submit', async (e) => {
        e.preventDefault();

        const username = document.getElementById('changeUsername').value;
        const currentPassword =
          document.getElementById('currentPassword').value;
        const newPassword = document.getElementById('newPassword2').value;

        // Get new crypto config
        const newOptions = {
          hashFunction: changeHashFunction.value,
          saltLength: parseInt(changeSaltLength.value),
          iterations: parseInt(changeIterations.value),
          keyLength: parseInt(changeKeyLength.value),
        };

        const result = await passwordManager.changePassword(
          username,
          currentPassword,
          newPassword,
          newOptions
        );

        if (result.changed) {
          showStatus(
            changeStatus,
            `Password for ${username} changed successfully!`,
            true
          );

          // Show performance comparison
          changeTimeResult.innerHTML = `
            <strong>Previous password:</strong> ${result.oldTime} ms<br>
            <strong>New password:</strong> ${result.newTime} ms
            <br><br>
            <strong>New configuration:</strong><br>
            • ${formatNumber(newOptions.iterations)} iterations<br>
            • ${newOptions.hashFunction} hash function<br>
            • ${newOptions.keyLength}-bit key length<br>
            • ${newOptions.saltLength}-byte salt
            <br><br>
            <strong>Old configuration:</strong><br>
            • ${formatNumber(result.oldConfig.iterations)} iterations<br>
            • ${result.oldConfig.hashFunction} hash function<br>
            • ${result.oldConfig.keyLength}-bit key length<br>
            • ${result.oldConfig.saltLength}-byte salt
            <br><br>
            <em>Note: Old password will be removed from the database</em>
          `;
          changePerformance.classList.remove('hide');

          changePasswordForm.reset();
          changeIterations.value = 100000;
          changeIterationsValue.textContent = '100,000';
          changeKeyLength.value = 256;
          changeKeyLengthValue.textContent = '256';
          updateUserTable();
        } else {
          showStatus(
            changeStatus,
            'Failed to change password. Invalid current password.',
            false
          );
          changePerformance.classList.add('hide');
        }
      });

      // Delete user form submission
      deleteUserForm.addEventListener('submit', async (e) => {
        e.preventDefault();

        const username = document.getElementById('deleteUsername').value;
        const password = document.getElementById('deletePassword').value;

        const deleted = await passwordManager.deleteUser(username, password);

        if (deleted) {
          showStatus(
            deleteStatus,
            `User ${username} deleted successfully!`,
            true
          );
          deleteUserForm.reset();
          updateUserTable();
        } else {
          showStatus(
            deleteStatus,
            'Failed to delete user. Invalid username or password.',
            false
          );
        }
      });

      // Delete user button in the table
      userTableBody.addEventListener('click', async (e) => {
        if (e.target.classList.contains('delete-btn')) {
          const username = e.target.dataset.username;
          const password = prompt(`Enter password to delete user ${username}:`);

          if (password) {
            const deleted = await passwordManager.deleteUser(
              username,
              password
            );

            if (deleted) {
              showStatus(
                deleteStatus,
                `User ${username} deleted successfully!`,
                true
              );
              updateUserTable();
            } else {
              showStatus(
                deleteStatus,
                'Failed to delete user. Invalid username or password.',
                false
              );
            }
          }
        }
      });

      // Initial load of user data into the table
      updateUserTable();
      // Load data from localStorage on page load
      passwordManager.loadFromStorage();
      // Update the table to show the loaded data
      updateUserTable();
    </script>
  </body>
</html>
